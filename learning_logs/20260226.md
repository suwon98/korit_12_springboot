# 수업 계획
1. Spring Data REST 적용으로 인해 커스텀 Controller 및 Service를 매우 제한적 사용
  - LoginController / JwtService
  - 그래서 Spring Data REST 의존성 삭제 후 Controller - Service - Repository로 이어지는 흐름을 Todo List로 확인할 예정
  - 이상의 흐름 동안에 필요한 개념이 DTO
  - 제한적으로 AccountCredentials record에서 확인했었음.
2. SpringBoot 프로젝트에서의 Google 로그인 기능(OAuth2)

# SpringBoot 3-Tier Architecture
- SpringBoot 프로젝트 상에서 애플리케이션의 유지보수성과 확장성을 높이기 위해 역할을 **분리**하는 표준적인 설계 방식으로 각 계층은 고유한 책임을 가지며,
  이 계층 사이를 이동할 때 DTO(Data Transfer Object)를 통하게 됩니다.

만약에 Entity class User에 id/username/passowed/name/address라고 하는 field들이 있다고 가정하겠습니다.
postman을 통해서 /login 엔드포인트를 통해 `{"username":"user", "password":"password"}`가 전송됐다고 했을 떄, 이는 Controller를 통해 들어오게 되고 이를 Repository에서 확인하게 될겁니다.
그래서 UserRepository의 findByUsername(String user)을 호출해서 특정 User 객체가 return 될겁니다.
그것이 Controller를 통해서 postman의 응답창에 출력됨.

## 종류
1. Controller(Presentation Layer) : 클라이언트의 요청(HTTP Request)을 가장 먼저 받는 관문 역할입니다. 요청 데이터를 검증하고, 비지니스 로직을 수행하기 위해 서비스 계층을 호출하며, 최종 결과를 응답(HTTP Response)으로 반환합니다(그래서 return 타입이 ResponseEntity<?>였습니다).
2. Service(Business Logic Layer) : 애플리케이션의 핵심 비지니스 로직이 수행되는 곳입니다. 데이터 가공, 트랜잭션 관리, 엔티티와 DTO 간의 변환 등을 담당합니다.
3. Repository(Data Access Layer) : 데이터베이스에 직접 접근하는 계층입니다. JPA를 사용했으니까 Entity 객체를 DB 테이블과 매핑하고, 실제 SQL을 실행하여 데이터를 처리합니다.
- 이상을 고려했을 때 postman에서 요청이 들어오면 Controller에서 요청을 검증하고 -> Service 계층으로 넘겨서 특정 정보가 있는지 여부를 체크하고 -> Repository에서 가져온 다음에 -> Service 계층에서 혹시 null 값이 있는지, 아니면 정보 조합이 되는지 여부를 따진 다음에 -> Controller로 보내서 올바르다면 postman에 제대로 띄울 것이고, 아니면 Error 메시지를 띄울겁니다.
- postman -> cotroller -> service -> repository -> db 
(여기까지 요청 부분)-> service -> controller 
(여기가 응답객체 리턴 부분) -> postmane

4. DTO(Data Transfer Object)
- 계층 간 데이터 이동시 데이터베이스 엔티티(예를 들면 Car, Owner, AppUser)를 직접 노출하지 않고 DTO를 사용합니다.
  - 보안 : 클라이언트에게 민감한 정보(password 등)가 노출되는 것을 방지
  - 결합도 down : DB 구조가 변경되어 엔티티가 수정되더라도 API 스펙(DTO)은 유지할 수 있습니다.
  - 유효성 검사 : 클라이언트가 보내는 데이터에 대해 특정 계층에서만 필요한 검증 로직을 추가하기에 용이.
  - 그래서 DTO의 경우 request 버전과 response 버전이 나뉘는 경우가 있습니다. 보낼 때는 username/password만 있지만 돌아올 때는 username/password/todos 혹은 cars 등이 있을 수 있으니까요.

## 3-Tier Architecture 구현(TodoList 기준)
1. build.gradle에서 spring-data-rest 를 삭제
2. 루트 패키지 내에 dto, repository, entity, service 패키지를 생성
3. 기존의 domain 내에 있던 .java 파일들을 각각 repositorydhk entity로 분할
4. dto 패키지 내에 TodoRequest / TodoResponse를 만들었습니다. record로 만든 이유는 불변 객체를 생성하기 위해서 이고, Java14 이후 버전부터는 class로 만들기보다 Record로 만들 것이 권장됩니다.
```java
// 보낼 때
package com.todo.todolist.dto;

public record TodoRequest(String content) {
}
// 돌아올 때
package com.todo.todolist.dto;

public record TodoResponse(Long id, String content, boolean is_completed) {
}

```
5. service 패키지 내에 TodoService
```java
package com.todo.todolist.service;

import com.todo.todolist.dto.TodoRequest;
import com.todo.todolist.dto.TodoResponse;
import com.todo.todolist.entity.Todo;
import com.todo.todolist.entity.User;
import com.todo.todolist.repository.TodoRepository;
import com.todo.todolist.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TodoService {
    private final TodoRepository todoRepository;
    private final UserRepository userRepository;
    
    // POST 요청을 하는 비지니스 로직 작성
    @Transactional
    public TodoResponse createTodo(Long userId, TodoRequest request) {
        User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다."));
        
        // DTO -> Entity로의 변환
        Todo todo = new Todo(request.content(), user);  // Todo 객체 만들어지면 isCompleted=false가 적용됩니다.
        Todo savedTodo = todoRepository.save(todo);
        
        // Entity -> DTO로 변환해서 Controller로 넘겨줄겁니다.
        return new TodoResponse(savedTodo.getId(), savedTodo.getContent(), savedTodo.isCompleted());
    }
    // GET 요청을 하는 비지니스 로직 작성
    @Transactional(readOnly = true)
    public List<TodoResponse> getTodoList() {
        return todoRepository.findAll().stream().map(todo -> new TodoResponse(todo.getId(), todo.getContent(), todo.isCompleted()))
                .collect(Collectors.toList());
    }
}
```

- 이상의 코드에서 다양한 repository를 field로 삼아서 메서드들을 호출한 다음, 필요한 정보들을 가공해서 TodoResponse 객체로 return 했다는 점을 확인할 수 있습니다.
그 내부 로직 중에 제어문의 다수가 쓰였다는 점, Lambda expression이 쓰이고 있다는 점에서 이전 Java에서의 배경지식이 요구된다는 것도 확인 가능.
그리고 .map() 꼭 확인(학습)

6. controller 패키지에 todoController 생성
```java
package com.todo.todolist.controller;

import com.todo.todolist.dto.TodoRequest;
import com.todo.todolist.dto.TodoResponse;
import com.todo.todolist.service.TodoService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/todos")
@RequiredArgsConstructor
public class TodoController {
    private final TodoService todoService;

    // todo 등록 API
    @PostMapping("/{userId}")
    public ResponseEntity<TodoResponse> addTodo(@PathVariable Long userId, @RequestBody TodoRequest request) {
        TodoResponse response = todoService.createTodo(userId, request);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    // todo 조회 API
    @GetMapping
    public ResponseEntity<List<TodoResponse>> getAllTodos() {
        return ResponseEntity.ok(todoService.getTodoList());
    }
}
```
- 이상의 코드에서 중요한 점은 여태까지 basePath=api로 잡아놨던 부분을 Controller 클래스에서 세팅해놨다는 점입니다.
  그래서 `@RestController` 뿐만 아니라 `@RequestMapping("/api/todos")`이 따로 존재합니다.
- 그리고 `@PostMapping("/{userId}")`로 되어있는 부분까지 합쳤을 떄, 결과적으로 http://localhost:8080/api/todos/{userId} 라고 해석할 수 있습니다.
- {userId}의 {}는 endpoint 상에서 달라질 수 있는 영역을 동적으로 받아와서 addTodo() 메서드의 매개변수로 쓰겠다는 것을 의미합니다.
- 그래서 이상의 경우에 사용된 애너테이션 두 개에 대해 작성합니다.
    1. `@RequestBody`
        - HTTP 요청 메서드(POST, PUT, PATCH)의 요청 본문(body)에 담긴 데이터를 읽어와 SpringController메서드의 매개변수로 연결(binding)할 때 사용.
        클라이언트가 서버로 데이터를 전송할 때 주로 사용합니다.
        즉 postman 상에서 body 란에 작성한 내용이 addTodo() 매개변수로 사용되었다고 볼 수 있겠습니다.
        그리고 그 형태가 TodoRequest 자료형이었습니다.

        - 특징 및 작동 원리
            1. 자동 역직렬화 : 요청 본문에 포함된 JSON / XML 등의 데이터를 메서드 매개변수로 지정된 Java 객체로 자동 변환해줍니다
            (즉 `@RequestBody` 애너테이션 덛ㄱ분에 TodoRequest로 변환되었다고 볼 수 있습니다).
            2. 메시지 컨버터(Message Converter) : Spring의 `HttpMessageConverter`가 담당하는 부분으로, JSON 데이터가 들어오게 되면 Jackson 라이브러리를 사용하는 컨버터가 이를 Java 객체로 변환해줍니다.
            3. 데이터 바인딩 : 요청 Body의 field 이름과 대상 Java 객체의 field 이름이 일치하면 자동으로 값이 주어집니다. 즉 JSON에서의 "content"와 TodoRequest의 field인 String content가 일치하기 때문에 값을 대입해줬다고 할 수 있습니다.
            4. 참고 사항 : 요청 본문이 없는 GET 요청에는 사용할 수 없으며 보통은 `POST, PUT`과 같이 데이터 전송이 필요한 요청에 사용됩니다.

    2. `@PathVariable`
        - 정의 및 목적 : 해당 애너테이션은 Spring Web에서 URL 경로 변수(path variable)에 있는 값을 추출하여 Controller의 메서드의 매개변수로 바인딩하는데 사용됩니다.
        이는 특정 리소스를 식별하거나 **조회** 할 때 RESTful API 디자인을 구현하는데 있어서 핵심적인 역할을 합니다.

        - 특징 및 작동 원리
            1. URL 경로 매핑 : URL 경로의 특정 부분을 변수처럼 `{id}`와 같이 표시하고, 그 변수에 할당된 실제값을 메서드의 매개변수로 사용하게 해줍니다.
            2. RESTful 식별자 : 주로 개별 리소스(특정 사용자 ID / 특정 상품 번호 등)를 식별하기 위해 사용되며 URI(Uniform Resource Identifier)의 의미를 명확하게 만들어줍니다.
            3. 자동 타입 변환 : 경로에서 추출된 문자열은 메서드의 매개변수 타입(Long, Integer, String 등)에 맞게 자동 변환됩니다.

## 추후 구현 목표
1. toggle 구현 : 현재 isCompleted가 false로 고정되어있는데 true로 바꾸는 기능이 빠져있다. 그러면 toggle 하려면 특정 todo의 field 값을 바꾸는 것이기 때문에 id 값이 필요하다.
그리고 PUT 요청이나 PATCH 요청을 통해서 {"isCompleted":true}로 요청을 보내게 되면 DB에 isCompleted 컬럼의 row가 1로 바뀌어야겠네요.
이 기능을 처리하기 위해서 Controller에 @PutMapping("/{todoId}")와 같은 메서드가 필요할 것 같습니다.
그리고 당연히 TodoService에서 update어쩌고 메서드가 필요하다.

2. 완료한거 말고 아예 삭제하고 싶으면 deleteTodo 쯤 되는 메서드도 있어야겠습니다. DELETE도 마찬가지로 하나만 지우고 싶다면 id값이 필요하겠네요.