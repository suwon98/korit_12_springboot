# RESTful API 명세서 작성
- RESTful API는 이용하는 개발자가 그 기능과 작동을 이해할 수 있도록 적절히 문서화가 되어야 합니다(어제 notion 예시 보여드렸습니다). 그리고 그 문서에는 이용할 수 있는 엔드포인트, 허용되는 데이터 형식, API와 상호작용하는 방법 등이 포함되어야 한다.

- 현재 저희는 Spring Data REST를 적용한 상태입니다. 즉 엔드포인트들이 자동생성되기 때문에 우리가 파악하지 못한 부분들이 있을 수 있어 API 명세서는 더 중요하다고 할 수 있습니다.

# SpringBoot의 Swagger / Open API
1. Swagger / Open API 란?
  - OpenAPI Specification(OAS) : RESTful API를 설계, 구축, 문서화하는 방법을 정의하는 표준 사양.
  - Swagger : 이상의 표준 사양을 구현하여 개발자가 API 구조를 시각적으로 확인하고 직접 테스트할 수 있도록 돕는 툴.
  - 도입 목적 : 백-프론트 간 협업 시 별도의 문서 작성 없이 실시간으로 업데이트 되는 API 명세서를 제공하기 위함.

# API 란 ?
## 정의
- Application Programming Interface의 축약어로 _서로 다른 소프트웨어가 대화할 수 있게 해주는 규칙이나 매개체_
- 손님(Client) : 주문을 하는 사람(앱이나 웹사이트)
- 주방(Server) : 요리를 하는 곳(데이터나 기능을 가진 시스템)
- 점원(API) : 손님의 주문을 주방에 전달하고, 주방에서 만든 음식을 다시 손님에게 가져다 주는 역할

- 이상에서의 중요한 점은 손님은 주방 안에서 어떤 일이 일어나는지(내부 로직) 알 필요가 없다는 점입니다. 점원에게 정해진 규칙(메뉴)대로 말하기만 하면 원하는 결과를 얻을 수 있다는 점이 핵심.

## API의 핵심 역할
1. 전달자 : 요청(request)을 받고 응답(response) - req / resp 로 작성하는 경우도 있음.
2. 보안/관문 : 아무나 데이터를 가져가지 못하게 인증된 사용자만 접근을 허용함(API Key를 활용합니다-챗봇 만들 때 써봤습니다).
3. 표준화 : 서로 다른 언어(Java / Python 등)로 만들어진 프로그램들이 같은 규칙으로 소통하게끔 한다.

- 우리가 만든 백엔드의 Controller 클래스가 API의 입구가 됩니다. 즉, Controller 클래스는 프론트엔드에서 요청이 왔을 때 맨 처음 백엔드 상으로 처리하는 관문 역할을 하는 곳이라고 볼 수 있습니다.

## 프로젝트 설정
1. SpringBoot 3.xx 버전에서는 `jakarta`로 써야 합니다. 혹시 옛날 버전 들고 오면 `javax`로 작성하는 경우가 있습니다.
```java
implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.15'
```
- starter가 포함된 버전을 사용해야 오류가 나지 않습니다.
- mvn을 통할 경우 openapi를 검색하면 너무 뭐가 많이 나오는데 starter/webmvc 존재 유무로 체크하시면 됩니다.

2. application.properties 수정
- Swagger UI의 경로와 API 문서의 기본 정보를 설정합니다. 현재 저희는 Spring Data REST 때문에 basePath가 `/api`로 설정되어있습니다.
```java
# Swagger UI access path config(default : /swagger-ui/index.html)
springdoc.swagger-ui.path=/swagger-ui.html

# open api doc path
springdoc.api-docs.path=/api-doce

# Integrated Configuration related to the Spring Data REST
springdoc.show-data-rest=true
```

예를 들어 이상까지만 작성했더라도 http://localhost:8080/swagger-ui/index.html 로 접속했을 경우에
![alt text](image-4.png)
이렇게 뜹니다.

3. API 문서 상세 설정
```java
package com.korit12.cardatabase.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {
    @Bean
    public OpenAPI cardatabaseOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Car Database API")
                        .description("자동차 및 소유주 관리를 위한 REST API 명세서")
                        .version("1.0.0")
                );
    }
}
```
- `@Bean` : 메서드 레벨의 애너테이션으로, Spring 컨테이너에 의해 관리되는 객체인 빈을 정의하고 등록하는 역할을 함.

1. `@Bean` 의 정의
  - 객체 등록 : 해당 메서드가 반환하는 객체를 Spring의 IoC(Inversion of Control) 컨테이너가 관리하는 빈으로 등록하도록 지시합니다.
  - 설정 소스 : 보통 `@Configuration` 애너테이션이 붙은 클래스 내에서 사용되며, 이 클래스는 빈 정의를 제공하는 소스 역할을 합니다.
  - 수동 등록 : 개발자가 직접 제어할 수 없는 외부 라이브러리 객체를 생성하거나, 복잡한 초기화 로직이 필요한 객체를 Spring 컨테이너

```java
package com.korit12.cardatabase.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration  // 빈 정의를 제공하는 소스 클래스라는 것을 명시
public class OpenApiConfig {
    @Bean // 메서드 리턴 객체를 Spring 빈으로 등록
    public OpenAPI cardatabaseOpenAPI() {
      // 직접 OpenAPI 객체를 생성하고 커스터마이징(빌더패턴을 통해) 함.
        return new OpenAPI()
                .info(new Info()
                        .title("Car Database API")
                        .description("자동차 및 소유주 관리를 위한 REST API 명세서")
                        .version("1.0.0")
                );
    }
}
```
- 상세 동작 관련 추가 설명
    1. 설정 소스 인식 : SpringBoot 애플리케이션이 실행될 때 `@Configuration`이 붙은 클래스를 스캔하여 빈 정의 소스로 인식.
    2. 메서드 실행 및 등록 : 클래스 내부에서 `@Bean`이 붇은 cardatabaseAPI() 메서드를 Spring이 직접 호출
    3. 빈 관리 : 이상의 메서드에서 return 된 OpenAPI 객체는 Spring 컨테이너 내에서 보관. 해당 객체는 나중에 Swagger UI가 API 명세서를 생성할 때, 제목 / 설명 / 버전 등의 정보를 제공하는 설정 데이터(Config)로 사용 됨.
    4. 유지보수성 향상 : 이처럼 `@Bean`을 통해 설정 정보를 분리, 관리하면 애플리케이션의 핵심 로직과 외부 설정 라이브러리 간의 결합도를 낮추고 유연하게 변경이 가능합니다.

# 카톡 취업 질문 대비 Bean 정리
Spring 프레임워크 상에서의 빈은 **스프링의 IoC(제어의 역전) 컨테이너가 생성하고 관리하는 자바 객체**를 의미함.

단순히 우리가 `new` 키워드를 이용하여 직접 생성하는 일반적인 Java 객체와는 달리 빈은 스프링 컨테이너에 의해 생명주기(생성, 초기화, 소멸)가 관리되는 것이 특징.

1. 빈의 핵심 역할 : 의존성 주입(DI : Dependency Injection)
    - 빈은 `ApplicationContext`라는 컨테이너를 통해 빈을 관리하며, 객체 간의 의존성을 자동으로 연결해줍니다(field, constructor, setter 주입 개념있었습니다).
    - 이상을 통해 코드 간의 결합도를 낮추고 유연성을 높일 수 있습니다.
    - 예시 : CarDatabaseApplication 클래스에서 직접 CarRepository 객체를 생성하지 않고 field 선언을 통해서 스프링이 관리하는 빈을 주입 받아 사용했습니다.

        - 이상의 경우에 CarRepository carRepository = new CarRepository(); 를 저희가 호출한 적이 없다는 점에서 Spring 컨테이너에서 알아서 객체 생성해서 field 주입을 했다고 해석할 수 있겠습니다.

2. 빈 등록 방법
    - `@Bean`은 빈을 수동으로 등록하는 방법 중 하나고, 위의 예시를 생각했을 때는
    - 컴포넌트 스캔을 통해서 더 자주 이루어집니다. 컴포넌트 스캔이란, 특정 애너테이션이 붙은 클래스를 자동으로 검색하여 빈으로 등록하는 것을 의미합니다.
    - CarRepository에 애너테이션이 없는데요 라는 답변이 나올 수 있습니다.
        - `@Component` : 일반적인 컴포넌트 빈
        - `@Service` : 비지니스 로직을 처리하는 서비스 클래스
        - `@Repository` : 데이터베이스 접근을 담당하는 리포지토리 클래스
        - `@Controller / @RestController` : 웹 요청을 처리하는 컨트롤러 클래스
    - 설정 클래스에서 수동 등록 : @Configuration 내부에서 @Bean이 있으면 수동 등록이 됩니다.

3. 빈의 특징
    1. 관리 주체 : 개발자가 아니라 스프링 컨테이너가 객체를 관리합니다.
    2. 싱글톤 원칙 : 기본적으로 스프링은 빈을 단 하나만 생성하여 애플리케이션 전체에서 공유하여 재사용할 수 있도록 합니다(메모리 효율성)
    3. 명명 규칙 : 빈은 고유한 이름을 가지며, 스프링은 이 이름을 통해 필요한 곳에 적절한 빈을 찾아 주입합니다.

# 백엔드 보호
cardatabase3 만들고, 주석들 좀 지우기

1. Spring Security의 이해
2. JWT(JSON Web Token)으로 백엔드 보호
3. 역할 기반 보안(Role-based Security)

## 스프링 시큐리티
- Java 기반 웹 애플리케이션을 위한 보안 서비스 제공 라이브러리.

- default 설정 값
1. 인메모리 사용자 하나를 포함하는 `AuthenticationManager` 빈. username은 user, 암호는 console창에 출력됩니다(마치 h2사용했을 때 uri 경로가 임시적으로 발급됐던 것과 동일합니다).
2. `/css`, `/images`와 같은 일반적인 정적 리소스 위치(resources/static에 보통 작성했었습니다)의 경로를 무시. 다른 모든 엔드포인트에 대한 HTTP에 인증을 요구함.
3. 스프링 자체에서의 `ApplicationEventPublisher` 인터페이스로 보호되는 보호 이벤트.
4. HSTS, XSS, CSRF 등 일반적인 저수준 기능을 기본적으로 활성화.
5. 자동 생성 로그인 페이지

- 의존성 추가할겁니다.

![alt text](image-5.png)

- http://localhost:8080으로 접속했을 떄, 혹은 /api까지 해서 접속했을 때 알아서 /login 엔드포인트로 넘어가면서 로그인할 것을 요구합니다.

- 이는 build.gradle에 spring security를 추가했기 때문에 생겨난겁니다.

- 그런데 재실행해보면 비밀번호 바뀌어있고 또 찾아서 로그인해야하고 그런 상황이 벌어집니다. username / password를 고정시키고 싶다면 스프링 시큐리티에 대한 Config 클래스를 정의해야만 합니다. 해당 클래스 내에서 특정 역할이나 사용자가 접근할 수 있는 URL 또는 URL 패턴을 정의할 수 있습니다. 또한 인증 메커니즘, 로그인 프로세스, 세션 관리 등도 정의할 수 있습니다.

- config 패키지 내에 SecurityConfig 클래스를 생성하시오.

```java
package com.korit12.cardatabase.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public InMemoryUserDetailsManager userDetailsService() {
        UserDetails user = User.builder()
                .username("user")
                .password(passwordEncoder().encode("password"))
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder () {
        return new BCryptPasswordEncoder();
    }
}
```

- 이상의 코드에서 `@Configuration, @EnableWebSecurity` 애너테이션은 default 웹 보호 구성을 해제하고, 개발자가 직접 Config 관련 설정을 정의할 수 있도록 허용합니다. 이후 수업에서 `filterChain(HttpSecurity http)` 메서드 내에서 애플리케이션의 어떤 엔드포인트가 보호되고 있는지, 어떤 엔드포인트가 보호되고 있지 않은지 정의할 수 있다.(인메모리 벗어나면 설명 예정)

- UserDetailsService를 구현하는 스프링 시큐리티의 InMemoryUserDetailsService를 이용하여 애플리케이션에 인메모리 user를 추가했습니다(사실 테스트용으로만 적합합니다). 메모리에 저장된 user/password 인증을 구현했습니다. Builder pattern을 이용했습니다.

- H2에서 확인하셨듯이 인메모리 사용자는 DB에 저장된 것이 아니기 때문에 껐다 켜면 초기화가 이루어집니다. User 관련 속성을 DB에 저장하고 싶다면 Car / Owner와 마찬가지로 엔티티 클래스와 리포지토리 클래스를 정의해야만 합니다. 그리고 암호는 일반 텍스트 형식으로 DB에 저장하면 보안문제가 생기겠네요.

- AppUser 엔티티 클래스와 리포지토리 클래스를 생성하시오.

- findByUsername 메서드를 정의하시오. -> 어디에 어떻게 적을지 떠올라야 한다는 점입니다.
```java
package com.korit12.cardatabase.domain;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUser, Long> {
    Optional<AppUser> findByUsername(String username);
}
```

- 이상에서 주목해야 할 것은 여태까지 CarRepository에 추상 메서드들을 정의했을 때는 결과값들이 기본적으로 복수로 나오기 때문에 List 자료형을 썼스빈다. 하지만 findByUsername() 메서드의 경우에는 AppUser의 field인 username이 기본적으로 `@column(nullable=false, unique=true)`라는 설정 때문에 결과값이 하나거나, 아니면 0개 입니다. 그렇다면 return type을 list로 설정하는 것은 적절하지 않은 선택지가 될겁니다. 그래서 옛날에는 NullPointException이 발생하는 문제가 생겼었습니다. 이를 해결하기 위해서는
```java
public AppUser findByUsername(String username) {
  if(username이 DB 내에서 일치하는 username이 있다면) {
    return 일치하는 객체 전체를 return(AppUser자료형이니까)
  }
  return null;
}
```
과 같은 방식으로 미리 예외처리를 해줘야만 했습니다. 그런데 AppUserRepository는 인터페이스니까 일반 메서드를 만들 수 없습니다. 즉, findByUsername()이 필요할 때 마다 이상의 로직이 항상 필요하다는 문제점이 생겼습니다. 이를 해결하기 위한 자료형이 `Optional`에 해당합니다.

- 이건 처음 배우는 자료형에 해당합니다. Optional 내부에는 null이 존재할 수 있는데, 그 상황에서도 예외가 발생하지 않습니다. 다만 Optional 내부에 AppUser 자료형이 존재한다면, AppUser 객체를 꺼내는 별개의 메서드를 호출할 필요는 있습니다.

- domain과 동일한 수준에 service 패키지를 생성 -> 내부에 UserDetailsServiceImpl 이라는 클래스를 생성
```java
package com.korit12.cardatabase.service;

import com.korit12.cardatabase.domain.AppUser;
import com.korit12.cardatabase.domain.AppUserRepository;
import lombok.AllArgsConstructor;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.User.UserBuilder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Optional;

// UserDetailsService 인터페이스 구현
@Service
@AllArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {
    // field 선언
    private AppUserRepository appUserRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<AppUser> user = appUserRepository.findByUsername(username);

        UserBuilder builder = null;
        if(user.isPresent()) {  // 이하의 실행문이 실행된다면 user에 AppUser 객체가 있다는 의미 -> 아직 user는 Optional 자료형이니까요.
            AppUser currentUser = user.get();   // Optional에서 제네릭으로 존재하는 객체를 빼내는 메서드가 .get()입니다.
            builder = User.withUsername(username)
                    .password(currentUser.getPassword())
                    .roles(currentUser.getRole());  // AppUser에 @Data 달아놨습니다.
        } else {
            throw new UsernameNotFoundException("해당 username을 가진 사용자를 찾지못했습니다.");
        }
        return builder.build();
    }
}
```

- 이상의 코드에서 집중해서 봐야할 점은 일단 클래스명입니다. UserDetailsServiceImpl이라는 이름을 지니고 있는데, 이는 대표적인 인터페이스를 구현(implement)한 클래스를 나타내는 클래스 명명법으로 `인터페잉스명+Impl`을 기준으로 작성합니다. 즉, UserDetailsService라는 인터페이스의 추상 메서드를 구현한 클래스라서 UserDetailsServiceImpl이 되는겁니다. 최초 명명법 발생 당시에는 가독성을 높이기 위한 클래스 이름짓기 방식이었다고 봐야합니다.

- loadUserByUsername() 메서드 내부에서 AppUser 클래스의 인스턴스인 user(객체명입니다)를 그대로 쓰는 것이 아니라 어디서 UserBuilder라고 이상한거 가지고 와서 선언하고,
거기 내부에 AppUser의 field의 값들을 하나씩 대입한 다음에 return했다는 점입니다.
이는 인터페이스의 정의를 명확하게 알지 못하면 효율적이지 못한 코드로 해석될 여지가 있습니다.
인터페이스는 추상 메서드만 존재합니다. 그리고 이를 구현하는 클래스는 인터페이스 내에 있는 추상 메서드들을 강제로 구현해야만 합니다.
우리가 AppUser라고 하는 엔티티 클래스를 만들기 이전에 인터페이스가 존재했고, 이를 구현했으므로 당연히 추상 메서드들의 return type은 AppUser가 될 수 없습니다. 
또한 다른 개발자들도 이 인터페이스를 그대로 갖다 쓸 것이기 때문에 자료형에 대한 보편적인 폼이 존재해야만 하곘네요. 
그렇게 추상 메서드인 loadUserByUsername()의 return 타입이 고정되어 있으므로 우리는 우리가 만든 entity class의 객체를 UserDetails 클래스의 객체 형태로 대입해주는 과정을 거쳐야만 합니다. 
그래서 if문 내부의 실행문에서 대입 로직이 존재하게 됩니다. else는 당연히 일치하는 AppUser가 없다는 뜻이므로 예외처리를 하게 되구요.

- 이후는 스프링 시큐리티가 인메모리 사용자 대신에 방금 만든 AppUser 관련 데이터베이스의 사용자를 참조하게끔 코드를 수정할 예정입니다.
```java
package com.korit12.cardatabase.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public InMemoryUserDetailsManager userDetailsService() {
        UserDetails user = User.builder()
                .username("user")
                .password(passwordEncoder().encode("password"))
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder () {
        return new BCryptPasswordEncoder();
    }
}
```
인메모리 날리기 전에 참조할 수 있도록 코드 기록 남김
```java
package com.korit12.cardatabase.config;

import com.korit12.cardatabase.service.UserDetailsServiceImpl;
import lombok.AllArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration
@EnableWebSecurity
@AllArgsConstructor
public class SecurityConfig {
    private UserDetailsServiceImpl userDetailsService;

    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception{
        auth.userDetailsService(userDetailsService);
    }

    @Bean
    public PasswordEncoder passwordEncoder () {
        return new BCryptPasswordEncoder();
    }
}
```

bcrypt는 닐스 프로보스 / 데이비드 마지에르가 설계한 해싱함수로, 예를 들어 `$2a$12$/7b2S6FRqi/gjgSWhRMp0e6lmIHWXrxf72WJCxdEX2OdgVWPEwQk2` 는 admin 문자열에서 생성되는 bycript의 예시입니다.

`$2a`는 알고리즘 버전을 의미하고, `$12`는 알고리즘 강도를 나타냅니다. 그리고 Spring Security 상에서의 BycryptPasswordEncoder의 기본 강도는 10으로 되어있습니다.

```java
{
    "_embedded": {
        "appUsers": [
            {
                "username": "user",
                "password": "$2a$12$bbW2ISVQIHIE49S/BD6ceuAvq8kGma9Lps1E4VPNuEkCtUoJVhD1.",
                "role": "User",
                "_links": {
                    "self": {
                        "href": "http://localhost:8080/api/appUsers/1"
                    },
                    "appUser": {
                        "href": "http://localhost:8080/api/appUsers/1"
                    }
                }
            },
            {
                "username": "admin",
                "password": "$2a$12$/7b2S6FRqi/gjgSWhRMp0e6lmIHWXrxf72WJCxdEX2OdgVWPEwQk2",
                "role": "ADMIN",
                "_links": {
                    "self": {
                        "href": "http://localhost:8080/api/appUsers/2"
                    },
                    "appUser": {
                        "href": "http://localhost:8080/api/appUsers/2"
                    }
                }
            }
        ]
    },
    "_links": {
        "self": {
            "href": "http://localhost:8080/api/appUsers?page=0&size=20"
        },
        "profile": {
            "href": "http://localhost:8080/api/profile/appUsers"
        },
        "search": {
            "href": "http://localhost:8080/api/appUsers/search"
        }
    },
    "page": {
        "size": 20,
        "totalElements": 2,
        "totalPages": 1,
        "number": 0
    }
}
```
라는 결과값을 얻게 됩니다. 그러니까 자기가 로그인만 되어있으면 다른 사람들 비밀번호 해싱 함수 버전을 얻을 수 있다는 것을 의미합니다.

그래서 AppUserRepository를 통해서 요청을 날리지 못하도록 설정하겠습니다. 그리고 이는 Spring Data REST 때문에 자동으로 AppUser 관련 엔드포인트가 생성되었기 때문입니다.